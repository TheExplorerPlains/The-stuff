-- Corruptor_Server.lua
-- Place this Script in ServerScriptService.
-- WARNING: This is visual-only and reversible. It will not permanently delete parts.
-- Author: ChatGPT (for your Roblox project). Customize the SETTINGS below.

local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerStorage = game:GetService("ServerStorage")
local Debris = game:GetService("Debris")

math.randomseed(tick())

-- SETTINGS (tweak these)
local SCAN_INTERVAL = 0.18         -- seconds between scheduling corrupt effects across parts (controls wave speed)
local CORRUPT_PLAYERS = false      -- set true to include player characters (may be intense)
local MAX_SIMULTANEOUS = 120      -- cap how many parts we'll corrupt concurrently to avoid overload
local GLITCH_DURATION = 20        -- seconds for each part's active corruption (per-pass). 0 = permanent (not recommended)
local JITTER_INTENSITY = 0.025    -- how much CFrame jitter (radians)
local PARTICLE_CHANCE = 0.55      -- chance to spawn particle emitter per part
local BILLBOARD_CHANCE = 0.40     -- chance to add a corrupted billboard on part
local SOUND_CHANCE = 0.25         -- chance to play an eerie sound (server plays, replicates to clients)
local MATERIAL_OPTIONS = {
    Enum.Material.Neon,
    Enum.Material.SmoothPlastic,
    Enum.Material.Glass,
    Enum.Material.ForceField,
    Enum.Material.Fabric
}

-- Create a ReplicatedEvent to let client do camera / screen glitching (optional local script uses it)
local eventName = "Corruptor_Remote"
local remote = ReplicatedStorage:FindFirstChild(eventName) or Instance.new("RemoteEvent")
remote.Name = eventName
remote.Parent = ReplicatedStorage

-- STORAGE for original properties so we can undo everything
local originals = {}     -- map part -> {props...}
local active = {}        -- set of currently corrupted parts
local spawnedEffects = {} -- map part -> list of created helper instances for cleanup

-- Helpers
local function isBasePart(obj)
    return obj and obj:IsA("BasePart")
end

-- Safely store properties we will change
local function snapshot(part)
    if not isBasePart(part) then return end
    if originals[part] then return end
    originals[part] = {
        Color = part.Color,
        BrickColor = part.BrickColor,
        Material = part.Material,
        Transparency = part.Transparency,
        Reflectance = part.Reflectance,
        Anchored = part.Anchored,
        CanCollide = part.CanCollide,
        Size = part.Size,
        CFrame = part.CFrame,
        Name = part.Name,
    }
end

-- Restore a single part
local function restorePart(part)
    if not originals[part] then return end
    local snap = originals[part]
    if part and part.Parent then
        pcall(function()
            part.Color = snap.Color
            part.BrickColor = snap.BrickColor
            part.Material = snap.Material
            part.Transparency = snap.Transparency
            part.Reflectance = snap.Reflectance
            part.Anchored = snap.Anchored
            part.CanCollide = snap.CanCollide
            -- restore CFrame/Size if that makes sense
            if part:IsA("BasePart") and snap.CFrame then
                part.CFrame = snap.CFrame
            end
        end)
    end

    -- clean up helpers
    local helpers = spawnedEffects[part]
    if helpers then
        for _, obj in pairs(helpers) do
            if obj and obj.Parent then
                pcall(function() obj:Destroy() end)
            end
        end
        spawnedEffects[part] = nil
    end

    originals[part] = nil
    active[part] = nil
end

-- Restore everything
local function restoreAll()
    for p, _ in pairs(originals) do
        restorePart(p)
    end
    originals = {}
    active = {}
    spawnedEffects = {}
    -- tell clients to stop screen effects
    remote:FireAllClients("restore")
    print("[Corruptor] World restored.")
end

-- Utility: random HSV color (vivid)
local function randomVividColor()
    local h = math.random()
    local s = 0.7 + math.random() * 0.3
    local v = 0.9
    return Color3.fromHSV(h, s, v)
end

-- Make garbled text
local function garbleText()
    local chars = {"0","1","¥","∆","∑","✦","▒","▓","█","╳","?","*","Φ","Ξ"}
    local len = 4 + math.random(0,8)
    local out = {}
    for i = 1, len do out[i] = chars[math.random(1,#chars)] end
    return table.concat(out)
end

-- Create a particle emitter attached to part
local function createParticle(part)
    local pe = Instance.new("ParticleEmitter")
    pe.Name = "CorruptParticles"
    pe.LightEmission = 1
    pe.Rate = 20 + math.random(0,80)
    pe.Lifetime = NumberRange.new(0.4,1.8)
    pe.Speed = NumberRange.new(0, 6)
    pe.RotSpeed = NumberRange.new(-360,360)
    pe.Size = NumberSequence.new(0.2, math.random()*1.2 + 0.2)
    pe.Texture = "" -- empty uses default particle; leave so no external assets required
    pe.Parent = part
    return pe
end

-- Create a billboard GUI with corrupted text
local function createBillboard(part)
    local gui = Instance.new("BillboardGui")
    gui.Name = "CorruptBillboard"
    gui.AlwaysOnTop = true
    gui.Size = UDim2.new(0, 120, 0, 50)
    gui.StudsOffset = Vector3.new(0, math.min(part.Size.Y/2 + 1, 6), 0)

    local label = Instance.new("TextLabel")
    label.Size = UDim2.new(1,0,1,0)
    label.BackgroundTransparency = 1
    label.Text = garbleText()
    label.Font = Enum.Font.Arcade -- any readable font
    label.TextStrokeTransparency = 0.5
    label.TextTransparency = 0
    label.TextScaled = true
    label.Parent = gui

    gui.Parent = part
    return gui
end

-- Add an ephemeral sound to the part (server-sided)
local function createSound(part)
    local s = Instance.new("Sound")
    s.Name = "Corrupt_SFX"
    -- use a generated tone using SoundId? We won't use external assets, so we'll use a short beep if possible.
    -- NOTE: Without asset IDs, the sound will be silent. If you want audio, replace s.SoundId with a valid asset.
    s.Volume = 0.5 + math.random()*0.8
    s.RollOffMode = Enum.SoundRollOffMode.InverseTapered
    s.Parent = part
    -- Play safely in pcall (no id -> nothing)
    pcall(function() s:Play() end)
    -- schedule to remove
    Debris:AddItem(s, 6)
    return s
end

-- The main corruption behaviour applied to a single part
local function corruptPart(part)
    if not isBasePart(part) then return end
    if active[part] then return end
    if # (table.create and table.create(0) or {}) > MAX_SIMULTANEOUS then return end -- trivial guard

    active[part] = true
    snapshot(part)

    -- store helpers for cleanup
    spawnedEffects[part] = spawnedEffects[part] or {}

    -- randomly change material / color / transparency
    pcall(function()
        part.BrickColor = BrickColor.new(randomVividColor())
        part.Color = randomVividColor()
        part.Material = MATERIAL_OPTIONS[math.random(1,#MATERIAL_OPTIONS)]
        part.Transparency = math.clamp(math.random() * 0.7, 0, 0.9)
        part.Reflectance = math.random() * 0.7
        -- sometimes toggle collide/anchored to produce odd physics (use carefully)
        if math.random() < 0.08 then part.CanCollide = not part.CanCollide end
        if math.random() < 0.06 then part.Anchored = not part.Anchored end
    end)

    -- optionally add particle emitter
    if math.random() < PARTICLE_CHANCE then
        local pe = createParticle(part)
        table.insert(spawnedEffects[part], pe)
    end

    -- optionally add billboard
    if math.random() < BILLBOARD_CHANCE then
        local bb = createBillboard(part)
        table.insert(spawnedEffects[part], bb)
    end

    -- optionally add sound
    if math.random() < SOUND_CHANCE then
        local s = createSound(part)
        table.insert(spawnedEffects[part], s)
    end

    -- animate "glitch jitters" using a coroutine
    local stopTime = (GLITCH_DURATION > 0) and (tick() + GLITCH_DURATION) or math.huge
    coroutine.wrap(function()
        local baseCFrame = part.CFrame
        local jitterPhase = 0
        while tick() < stopTime and part and part.Parent and active[part] do
            -- small random rotation jitter
            jitterPhase = jitterPhase + math.random() * 0.3
            local rx = (math.noise(jitterPhase*1.3) - 0.5) * JITTER_INTENSITY
            local ry = (math.noise(jitterPhase*1.7 + 5.2) - 0.5) * JITTER_INTENSITY
            local rz = (math.noise(jitterPhase*1.9 + 9.4) - 0.5) * JITTER_INTENSITY
            -- wobbly translation
            local tx = (math.noise(jitterPhase*2.1 + 2) - 0.5) * (part.Size.Magnitude * 0.02)
            local ty = (math.noise(jitterPhase*2.4 + 7) - 0.5) * (part.Size.Magnitude * 0.02)
            local tz = (math.noise(jitterPhase*2.7 + 11) - 0.5) * (part.Size.Magnitude * 0.02)
            local jitterCFrame = CFrame.Angles(rx, ry, rz) * CFrame.new(tx, ty, tz)
            pcall(function()
                if part and part.Parent then
                    part.CFrame = baseCFrame * jitterCFrame
                end
            end)
            -- occasionally change billboard text
            if spawnedEffects[part] then
                for _, obj in pairs(spawnedEffects[part]) do
                    if obj:IsA("BillboardGui") and obj:FindFirstChildOfClass("TextLabel") then
                        local label = obj:FindFirstChildOfClass("TextLabel")
                        if math.random() < 0.15 then
                            label.Text = garbleText()
                            label.TextStrokeTransparency = math.random()
                            label.TextTransparency = math.random() * 0.8
                        end
                    end
                end
            end

            wait(0.06 + math.random() * 0.06)
        end

        -- clean up this part if GLITCH_DURATION elapsed
        if GLITCH_DURATION > 0 then
            restorePart(part)
        end
    end)()
end

-- Main wave function: corrupt everything in workspace (with exclusions)
local function corruptAll()
    print("[Corruptor] Starting corruption wave...")
    local queue = {}
    for _, obj in pairs(workspace:GetDescendants()) do
        if isBasePart(obj) then
            -- exclude terrain and things that would be catastrophic
            if not obj:IsDescendantOf(ServerStorage) and not obj:IsDescendantOf(ReplicatedStorage) then
                -- optionally skip player characters if disabled
                if not CORRUPT_PLAYERS and obj.Parent and obj.Parent:FindFirstChild("Humanoid") then
                    -- skip character parts
                else
                    table.insert(queue, obj)
                end
            end
        end
    end

    -- shuffle queue
    for i = #queue, 2, -1 do
        local j = math.random(1,i)
        queue[i], queue[j] = queue[j], queue[i]
    end

    -- spread out corruption across time to create a wave
    local corrupted = 0
    for i, part in ipairs(queue) do
        if corrupted >= MAX_SIMULTANEOUS then break end
        corruptPart(part)
        corrupted = corrupted + 1
        wait(SCAN_INTERVAL * (0.4 + math.random()*1.2))
    end

    -- notify clients for camera / screen-level corruption
    remote:FireAllClients("start", {intensity = 1.0, duration = GLITCH_DURATION})
    print("[Corruptor] Corruption wave scheduled on " .. tostring(corrupted) .. " parts.")
end

-- Expose a very simple interface to run/stop via server console (or call from other scripts)
local module = {}
module.corruptAll = corruptAll
module.restoreAll = restoreAll

-- Optional: bind to ServerScriptService Script's environment so you can call from Command Bar
_G.Corruptor = module

-- Auto-start after small delay for demo (comment this out if you want manual control)
delay(2, function()
    corruptAll()
end)

-- Print helpful message
print("[Corruptor] Loaded. Use _G.Corruptor.corruptAll() or _G.Corruptor.restoreAll() from server to control the effect.")